name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  token-job:
    permissions:
      contents: 'read'
      id-token: 'write'
    runs-on: ubuntu-latest
    name: Run Step 1
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get JWT
        id: auth-token
        run: |
          # Retrieve JWT from GitHub Actions
          TOKEN=$(curl -sSL -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL")
          if [ $? -ne 0 ]; then
            echo "Error retrieving initial JWT"
            exit 1
          fi

          # Get short-lived token from CyberArk
          shortLiveToken=$(curl -vvvk --request POST https://lvm-uat.secretsmgr.cyberark.cloud/api/authn-jwt/lvmtest/conjur/host%2Fdata%2Fjwtwork/authenticate --header "Content-Type:application/x-www-form-urlencoded" --data-urlencode jwt="$TOKEN")
          if [ $? -ne 0 ]; then
            echo "Error retrieving short-lived token"
            exit 1
          fi

          export shortLiveToken="$shortLiveToken"

          # Retrieve secret from CyberArk
          SECRET=$(curl -vvvk --request GET https://lvm-uat.secretsmgr.cyberark.cloud/api/secrets/conjur/variable/data%2Fvault%2FTest_VCP%2FApplication-ConjurPass-conjurtestvar3%2Fpassword -H "Authorization: Bearer $shortLiveToken")
          if [ $? -ne 0 ]; then
            echo "Error retrieving secret"
            exit 1
          fi

          # Mask the secret in the output
          echo "::add-mask::$SECRET"

          # Use the secret (example: write to a file - be very careful with this!)
          echo "$SECRET" > secret.txt
          echo "Secret written to secret.txt (but is masked in output)"
      
      - name: Example usage of secret file
        run: |
          # Example of how to use the secret after retrieving it
          cat secret.txt
